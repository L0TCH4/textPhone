<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text Phone</title>
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<style>
body {
  margin: 0;
  font-family: system-ui, sans-serif;
  background: #0f0f0f;
  color: #fff;
  height: 100vh;
  display: flex;
  flex-direction: column;
}
header {
  padding: 8px;
  background: #181818;
  font-size: 14px;
}
#remote, #localView {
  flex: 1;
  padding: 16px;
  font-size: 20px;
  line-height: 1.4;
  word-break: break-all;
}
#remote {
  border-bottom: 1px solid #333;
}
.char {
  opacity: 1;
  transition: opacity 0.4s;
}
.char.dead {
  opacity: 0;
}
#composing {
  opacity: 0.6;
}
footer {
  padding: 8px;
  background: #181818;
}
input, button {
  font-size: 16px;
}
#nameInput, #peerInput {
  width: 100%;
  margin-bottom: 6px;
}
#textInput {
  width: 100%;
  font-size: 20px;
  padding: 8px;
}
</style>
</head>
<body>

<header>
  Your ID: <span id="myId">...</span>
</header>

<div id="remote"></div>
<div id="localView"></div>

<footer>
  <input id="nameInput" placeholder="あなたの名前">
  <input id="peerInput" placeholder="相手のPeer ID">
  <button onclick="connect()">接続</button>
  <input id="textInput" placeholder="話すように入力…" autocomplete="off">
</footer>

<script>
const peer = new Peer();
let conn = null;
const TTL = 3000;

const remote = document.getElementById("remote");
const localView = document.getElementById("localView");
const textInput = document.getElementById("textInput");

let isComposing = false;
let composingSpan = null;

peer.on("open", id => {
  document.getElementById("myId").textContent = id;
  const p = new URLSearchParams(location.search);
  if (p.get("connect")) {
    document.getElementById("peerInput").value = p.get("connect");
  }
});

peer.on("connection", c => {
  conn = c;
  setupConn();
});

function connect() {
  const id = document.getElementById("peerInput").value;
  conn = peer.connect(id);
  setupConn();
}

function setupConn() {
  conn.on("data", data => {
    spawnChar(remote, data.char);
  });
}

function spawnChar(target, char) {
  const span = document.createElement("span");
  span.className = "char";
  span.textContent = char;
  target.appendChild(span);

  setTimeout(() => span.classList.add("dead"), TTL);
  setTimeout(() => span.remove(), TTL + 500);
}

/* ===== IME対応 ===== */

textInput.addEventListener("compositionstart", () => {
  isComposing = true;
  composingSpan = document.createElement("span");
  composingSpan.id = "composing";
  localView.appendChild(composingSpan);
});

textInput.addEventListener("compositionupdate", e => {
  if (composingSpan) {
    composingSpan.textContent = e.data;
  }
});

textInput.addEventListener("compositionend", e => {
  isComposing = false;
  if (composingSpan) composingSpan.remove();
  composingSpan = null;

  const text = e.data;
  for (const char of text) {
    spawnChar(localView, char);
    if (conn && conn.open) {
      conn.send({ char });
    }
  }
  textInput.value = "";
});

textInput.addEventListener("input", e => {
  if (isComposing) return; // IME中は無視

  const text = e.target.value;
  if (!text) return;

  for (const char of text) {
    spawnChar(localView, char);
    if (conn && conn.open) {
      conn.send({ char });
    }
  }
  e.target.value = "";
});
</script>

</body>
</html>
